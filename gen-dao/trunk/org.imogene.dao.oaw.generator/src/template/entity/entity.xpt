«IMPORT core»
«EXTENSION template::CommonFieldUtilExt» 
«EXTENSION template::CommonEntityUtilExt»
«EXTENSION template::DaoUtilExt»

«DEFINE generate(String projectName) FOR CardEntity»
«FILE projectName.toLowerCase()+"/domain/entity/"+this.name.toFirstUpper() + ".java"»
package org.imogene.«projectName.toLowerCase()».domain.entity;

import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import javax.persistence.Column;
import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;

import org.imogene.lib.common.entity.GeoField;
import org.imogene.lib.common.entity.ImogActorImpl;
import org.imogene.lib.common.entity.ImogBeanImpl;
import org.imogene.lib.common.entity.IsGeoreferenced;
import org.imogene.lib.common.role.ImogRole;
import org.imogene.lib.common.sync.entity.SynchronizableEntity;

/**
 * ImogBean implementation for the entity «name.toFirstUpper()»
 * @author MEDES-IMPS
 */
@Entity
public class «name.toFirstUpper()» extends «IF Actor.isAssignableFrom(metaType)»ImogActorImpl«ELSE»ImogBeanImpl«ENDIF»«IF georeferenced != null» implements IsGeoreferenced«ENDIF» {

	/**
	 * Serial version
	 */
	private static final long serialVersionUID = «generateSerialVersionUID()-»L;

	«IF Actor.isAssignableFrom(metaType)-»
	private static final String[] AUTHORIZED_ROLES = new String[] {
		«IF !((Actor)this).authorizedRoles.isEmpty»
			«FOREACH ((Actor) this).authorizedRoles AS role SEPARATOR ','»"«role.name»"«ENDFOREACH»   
		«ELSE»
			«FOREACH ((Project) this.eContainer).roles  AS role SEPARATOR ','»"«role.name»"«ENDFOREACH»,
			"administrator",
			"delete",
			"export"
		«ENDIF -»  
	};
	«ENDIF-»
	
	/* Entity fields */	
	«EXPAND fieldDeclaration FOREACH groups.fields»
	
	«IF isTranslatableFieldPresent(groups.fields)-»
	/* For localized fields */
	@Transient
	private LocalizedFieldMap localizedFieldMap = new LocalizedFieldMap();	
	«ENDIF»
	
	
	public «name.toFirstUpper()»(){
		«IF Actor.isAssignableFrom(metaType) && ((Actor) this).notificationInfos != null-»
		Map<String, String> map = new HashMap<String, String>();
		«FOREACH ((Actor) this).notificationInfos AS nf-»
		map.put("«nf.method»", "«EXPAND template::CommonFieldUtil::getterName FOR nf.dataField-»");
		«ENDFOREACH -»
		setNotificationData(map);
		«ENDIF-»
	}
	
	/* Getters and Setters for Entity fields */
	
	«FOREACH groups AS g-»
	/* Getters and Setters for «g.name.toFirstUpper()» group fields */
	«FOREACH g.fields AS f -»
	
	«EXPAND template::DaoFieldUtil::getterDeclarationForField FOR f»
	«EXPAND template::DaoFieldUtil::setterDeclarationForField FOR f»	
	«REM»
	When a property has a lowercase first char and an upper case second char,
	some bean introspectors need getter/setter with type getXxxx
	and some other need getter/setter with type getxxx
	«ENDREM»
	«IF isPropertyWithLowerUpperCaseFirstTwoChar(f.name)-»
	/* second set of getter/setter because of property has first char with lowercase and second char with uppercase 
	   and bean introspectors do not use same naming conventions */
	«EXPAND template::DaoFieldUtil::getterDeclarationForFieldWithLowerUpperCaseFirstTwoChar FOR f»
	«EXPAND template::DaoFieldUtil::setterDeclarationForFieldWithLowerUpperCaseFirstTwoChar FOR f-»
	/* ----------------------------------------------------------------------------------------------------------- */
	«ENDIF-»
	
	«EXPAND specificMethodForRelation FOR f-»
	
	«ENDFOREACH -»	
	«ENDFOREACH»
	
	«IF isTranslatableFieldPresent(this.groups.fields)-»
	public LocalizedFieldMap getLocalizedFieldMap() {
		return localizedFieldMap;
	}

	public void setLocalizedFieldMap(LocalizedFieldMap localizedFieldMap) {
		this.localizedFieldMap = localizedFieldMap;
	}
	«ENDIF»	
	
	«IF georeferenced != null -»
	@Override
	public Double getLatitude() {
		return «EXPAND template::CommonFieldUtil::propertyName FOR georeferenced» != null ? «EXPAND template::CommonFieldUtil::propertyName FOR georeferenced».getLatitude() : null;
	}
	
	@Override
	public Double getLongitude() {
		return «EXPAND template::CommonFieldUtil::propertyName FOR georeferenced» != null ? «EXPAND template::CommonFieldUtil::propertyName FOR georeferenced».getLongitude() : null;
	}
	«ENDIF»	
	
	«IF Actor.isAssignableFrom(this.metaType)-»
	
	private boolean isAuthorizedRole(String roleId) {
		for (String role : AUTHORIZED_ROLES) {
			if (role.equals(roleId)) {
				return true;
			}
		}
		return false;
	}
	
	@Override
	public void addRole(ImogRole role) {

		if (!isAuthorizedRole(role.getId())) {
			throw new IllegalArgumentException(
					"The role "
							+ role.getName()
							+ " can not be assigned to this actor (not defined as an authorized role), for actor : «name.toFirstUpper()»");
		}

		if (!isAssignedRole(role.getId())) {
			super.addRole(role);
		}
	}
	
	«EXPAND filterField FOREACH ((Actor)this).filters-»
	
	«ENDIF-»
	
}
«ENDFILE»
«ENDDEFINE»




«DEFINE fieldDeclaration FOR FieldEntity»
	«EXPAND jpaAnnotation FOR this»
	private «EXPAND template::DaoFieldUtil::entityFieldType FOR this -» «EXPAND template::CommonFieldUtil::propertyName FOR this»; 
«ENDDEFINE»



«DEFINE jpaAnnotation FOR FieldEntity-»«ENDDEFINE»

«DEFINE jpaAnnotation FOR DatesField»
	@Temporal(TemporalType.TIMESTAMP)
«ENDDEFINE»

«DEFINE jpaAnnotation FOR GeoField»
	@Embedded
	@AttributeOverrides({
    	@AttributeOverride(name="latitude", column=@Column(name="«name.toFirstLower()»Latitude")),
    	@AttributeOverride(name="longitude", column=@Column(name="«name.toFirstLower()»Longitude"))
  	})
«ENDDEFINE»

«DEFINE jpaAnnotation FOR MainRelationFieldEntity»
«IF cardinality == 1 -»
	«IF getOppositeCardinality(this) == 1 -»
	@OneToOne
	«ELSE-»
	@ManyToOne
	«IF oppositeRelationField != null-»
	@JoinColumn(name = "«EXPAND template::CommonFieldUtil::propertyName FOR oppositeRelationField»«oppositeRelationField.parentGroup.parentCard.name.toFirstUpper()»_id")
	«ENDIF-»
	«ENDIF-»
«ELSE-»
	«IF getOppositeCardinality(this)  == 1 -»
	@OneToMany(fetch = FetchType.LAZY, orphanRemoval = «IF type == core::RelationType::Composition»true«ELSE»false«ENDIF»)
	@JoinColumn(name = "«EXPAND template::CommonFieldUtil::propertyName FOR this»«parentGroup.parentCard.name.toFirstUpper()»_id")
	«ELSE-»
	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(
		name = "«name.toFirstUpper()-»«parentGroup.parentCard.name.toFirstUpper()»«entity.name.toFirstUpper()»",
		joinColumns = @JoinColumn(
			name = "«parentGroup.parentCard.name.toLowerCase()»_id",
			referencedColumnName = "id"),
		inverseJoinColumns = @JoinColumn(
			name = "«entity.name.toLowerCase()»_id",
			referencedColumnName = "id"))
	«ENDIF-»
«ENDIF»
«ENDDEFINE»

«DEFINE jpaAnnotation FOR ReverseRelationFieldEntity»
«IF cardinality == 1 -»
	«IF getOppositeCardinality(this) == 1 -»
	@OneToOne(mappedBy="«EXPAND template::CommonFieldUtil::propertyName FOR oppositeRelationField»")
	«ELSE-»
	@ManyToOne
	@JoinColumn(name = "«EXPAND template::CommonFieldUtil::propertyName FOR oppositeRelationField»«oppositeRelationField.parentGroup.parentCard.name.toFirstUpper()»_id")	
	«ENDIF-»
«ELSE-»
	«IF getOppositeCardinality(this) == 1 -»
	@OneToMany(fetch = FetchType.LAZY, orphanRemoval = «IF type == core::RelationType::Composition»true«ELSE»false«ENDIF»)
	@JoinColumn(name = "«EXPAND template::CommonFieldUtil::propertyName FOR this»«parentGroup.parentCard.name.toFirstUpper()»_id")
	«ELSE-»
	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(
		name = "«oppositeRelationField.name.toFirstUpper()-»«entity.name.toFirstUpper()»«parentGroup.parentCard.name.toFirstUpper()»",
		joinColumns = @JoinColumn(
			name = "«parentGroup.parentCard.name.toLowerCase()»_id",
			referencedColumnName = "id"),
		inverseJoinColumns = @JoinColumn(
			name = "«entity.name.toLowerCase()»_id",
			referencedColumnName = "id"))
	«ENDIF-»
«ENDIF-»
«ENDDEFINE»





«REM» Set the actor roles «ENDREM»
«DEFINE setAuthorizedImogRoles FOR Role-»              
        authorizedImogRoles.add("«name»");
«ENDDEFINE»



«REM» Set the project roles to the actor «ENDREM»
«DEFINE setProjectImogRoles FOR emf::EObject-»«ENDDEFINE»
«DEFINE setProjectImogRoles FOR Project-»              
       	«FOREACH this.roles AS r-»         
        authorizedImogRoles.add("«r.name»");
		«ENDFOREACH -»
		authorizedImogRoles.add("administrator");
		authorizedImogRoles.add("delete");
		authorizedImogRoles.add("export");
«ENDDEFINE»

«REM» Create variable, getter and setter for the filter fields «ENDREM»
«DEFINE filterField FOR FilterField»

	/** 
	 * filter fields for the «this.entity.name.toFirstUpper()» entity 	
	 */
	@ManyToMany(fetch = FetchType.EAGER)
	@JoinTable(
		name = "«EXPAND template::CommonFieldUtil::propertyName FOR this-»",
		joinColumns = @JoinColumn(
			name = "«parentActor.name.toLowerCase()»_id",
			referencedColumnName = "id"),
		inverseJoinColumns = @JoinColumn(
			name = "«entity.name.toLowerCase()»_id",
			referencedColumnName = "id"))
	private Set<«entity.name.toFirstUpper()»> «EXPAND template::CommonFieldUtil::propertyName FOR this»;
	
	/**
	 * Set the list of allowed «this.entity.name.toFirstUpper()» for card access.	
	 */
	public void «EXPAND template::CommonFieldUtil::setterName FOR this»(Set<«entity.name.toFirstUpper()»> filterFields){
		«EXPAND template::CommonFieldUtil::propertyName FOR this» = filterFields;
	}
	
	/**
	 * Get the list of allowed «this.entity.name.toFirstUpper()» for card access.
	 * @return a list of «this.entity.name.toFirstUpper()». 	
	 */
	public Set<«entity.name.toFirstUpper()»> «EXPAND template::CommonFieldUtil::getterName FOR this»(){
		return «EXPAND template::CommonFieldUtil::propertyName FOR this»;
	} 
«ENDDEFINE»

«DEFINE specificMethodForRelation FOR FieldEntity-»«ENDDEFINE»
«DEFINE specificMethodForRelation FOR RelationFieldEntity-»
«IF cardinality != 1-»
	/**
	 * @param param the «entity.name» to add to the «EXPAND template::CommonFieldUtil::propertyName FOR this» collection
	 */
	public void addTo«EXPAND template::CommonFieldUtil::propertyName FOR this»(«entity.name.toFirstUpper()-» param)
	{
		«IF getOppositeCardinality() == 1 && oppositeRelationField != null-»
		param.«EXPAND template::CommonFieldUtil::setterName FOR oppositeRelationField»(this);
		«ENDIF-»
		«EXPAND template::CommonFieldUtil::propertyName FOR this».add(param);
	}	
	
	/**
	 * @param param the «entity.name-» to remove from the «EXPAND template::CommonFieldUtil::propertyName FOR this» collection
	 */
	public void removeFrom«EXPAND template::CommonFieldUtil::propertyName FOR this»(«entity.name.toFirstUpper()» param)
	{
		«IF getOppositeCardinality() == 1 && oppositeRelationField != null-»
		param.«EXPAND template::CommonFieldUtil::setterName FOR oppositeRelationField»(null);
		«ENDIF-»
		«EXPAND template::CommonFieldUtil::propertyName FOR this».remove(param);
	}
«ENDIF-»
«ENDDEFINE»