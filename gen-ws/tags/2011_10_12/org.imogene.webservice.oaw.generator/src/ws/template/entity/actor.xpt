«IMPORT core»

«DEFINE generate(String packageName, String projectName) FOR CardEntity»«ENDDEFINE»
«DEFINE generate(String packageName, String projectName) FOR Actor»
«FILE packageName.toLowerCase() + "/entity/" + name.toFirstUpper() + "Actor.java"»
package org.imogene.«projectName.toLowerCase()».entity;

import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.Iterator;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;

import org.imogene.ws.entity.MedooActor;
import org.imogene.ws.entity.MedooRole;
import org.imogene.ws.entity.SynchronizableEntity;


/**
 * A Medoo actor : «name»
 * @author Medes-IMPS
 */
@XmlAccessorType(XmlAccessType.NONE)
@XmlRootElement(name="«name.toLowerCase()»")
public class «name.toFirstUpper()»Actor extends «name.toFirstUpper()» implements MedooActor {	
	
	/** Password stored for this login */
	private String login;
	
	/** Password stored for this actor */
	private String password;
	
	/** Default locale */
	private String notifLocale;
	
	/** The default notification method */
	private Integer defaultNotificationMethod;
	
    /** The actor is notified or not */ 
    private Boolean beNotified;	
		   
    /**
     * Notification data (one per method) Key = String for method, value = getter For data.
     * See the NotificationMethod enumerated values 
     */
    private HashMap<String, String> notificationData;
    
	/**
	 * List of entities that the actor coud synchronize
	 * from a disconnected client.
	 */
	private Set<SynchronizableEntity> synchronizables;

    /** Store the assigned roles as set in the external user management application */
    private Set<MedooRole> assignedRoles = new HashSet<MedooRole>();
 
 	/** The actor last login date */
	private Date lastLoginDate;         
        
    /** Initialize actor with all information extracted from model */
    public «name.toFirstUpper()»Actor() {
    	
       «IF this.notificationInfos != null -»
          notificationData = new HashMap<String, String>();
          «FOREACH notificationInfos AS nf-»        
            notificationData.put("«nf.method»", "«EXPAND template::CommonFieldUtil::getterName FOR nf.dataField-»");        
          «ENDFOREACH -»
  	   «ENDIF -»
    }
       
    
	/** 
	 * Get the assigned roles for this actor. 
	 * @return a list of role names (EMPTY_LIST if none). 	  
	 */
    public Set<MedooRole> getRoles() {
    	 return assignedRoles;
    }
    
	/**
	 * Set the list of roles assigned to this actor. 	 
	 * @param roles the list of roles assigned. 
	 */
    public void setRoles(Set<MedooRole> roles) {
        assignedRoles = roles;
    }      
    
    /** 
     * Add a role to this actor.
     * @param role the role to add.
     */
    public void addRole(MedooRole role) {    	
    	
        if (!isRoleAuthorized(role.getId())) {
            throw new IllegalArgumentException("The role " + role.getName() +
                " can not be assigned to this actor (not defined as an authorized role), for actor : «name.toFirstUpper()»Actor");
        }

        if (!isRoleAssigned(role.getId())) {
            assignedRoles.add(role);
        }
    }

	/** 
	 * Remove the specified role of this actor assigned roles
	 */
    public void removeRole(MedooRole role) {
        assignedRoles.remove(role);
    }

    
    /** 
     * Get the authorized roles for this actor. (defined in model).    
     * @return a list of roles names (EMPTY_LIST if none).  
     */
    public static Set<String> getAuthorizedRoles() {
    	
    	Set<String> authorizedRoles = new HashSet<String>();
    	    	
    	«IF !this.authorizedRoles.isEmpty -»
		    «FOREACH authorizedRoles AS role-»
				«EXPAND setAuthorizedRoles FOR role-»
			«ENDFOREACH -»   
		«ELSE -»
			«EXPAND setProjectRoles FOR this.eContainer-»				
		«ENDIF -»  
        
        return authorizedRoles;
    }
    

    
    /** 
     * Get this actor login.
     *@return the actor login
     */
    public String getLogin() {
       return login; 
    }
    
    /** 
     * Get the assigned password for this actor.
     *@return the actor password 
     */
    public String getPassword() {
        return password;
    }
  
   /**
    * Set the actor login.
    *@param pLogin the actor login.
    */
    public void setLogin(String pLogin) {
       login = pLogin; 
    }
    
    /**
     * set the actor password
     *@param pPassword the actor password 
	 */
    public void setPassword(String pPassword) {
        password = pPassword;
    }
  
    
    /** 
     * Get the notification locale ISO code to use for this actor
     *@return the locale ISO code
     */
    public String getNotificationLocale() {
       return notifLocale;
    }
    
    /** 
     * Set the notification locale ISO code
     *@param locale the locale ISO code
     */
    public void setNotificationLocale(String locale) {
       notifLocale = locale;
    }
    
   
    /** 
     * Get the notification method to use (if none : NO_METHOD). 
     * @return the notification method id
     */
    public Integer getNotificationMethod() {
    	return defaultNotificationMethod;
    }
    
    /**
     * Set the notification method to use.
     *@param method the notification method
     */
    public void setNotificationMethod(Integer method) {
    	defaultNotificationMethod = method;
    }

   /**
    * get th notification data (ie: phone number, email) 
    * for the specified notification method.
    * @param method the notification method
    * @return the data associated with the method
    */
    public String getNotificationDataMethodName(String method) {    	
    	return (String)notificationData.get(method);
    }
    
    
    /** 
     * This actor can be notified ?
     *@return true if actor can be notified.
     */
    public Boolean getBeNotified() {
        return beNotified;
    }


	/**
	 * Set if this actor can be notified
	 *@param notif true if it can be notified
	 */
    public void setBeNotified(Boolean notif) {
    	beNotified = notif;
    }    
   
	
	/** 
	 * Is the specified role already assigned to the user ?
	 * @param roleId the role id
	 * @return true it is already assigned
	 */
	private boolean isRoleAssigned(String roleId) {
		boolean result = false;    	
    	if(assignedRoles != null) {
    		for(Iterator<MedooRole> it = assignedRoles.iterator(); it.hasNext() && !result;){
    			MedooRole currRole = (MedooRole)it.next();
    			result = currRole.getId().equals(roleId);
    		}    		
    	}    	
    	return result;
	}
	
	/** */
	private boolean isRoleAuthorized(String roleId) {	
		boolean result = false;    		
    	if (getAuthorizedRoles()!=null)	{
    		for (Iterator<String> iter = getAuthorizedRoles().iterator(); iter.hasNext() && !result;) {
    			String currRoleId = (String) iter.next();				
    			result = currRoleId.equals(roleId);
    		}						
    	}    		    	
    	return result;
	}
		
	@Override
	public Date getLastLoginDate() {
		return lastLoginDate;
	}
	
	
	@Override
	public void setLastLoginDate(Date date) {
		this.lastLoginDate = date;
	}
	
	@Override
	public Integer getDefaultNotificationMethod() {
		
		return null;
	}

	@Override
	public void setDefaultnotificationMethod(Integer method) {
			
	}
	
	public void setSynchronizables(Set<SynchronizableEntity> syncs) {
		synchronizables = syncs;
	}

	public Set<SynchronizableEntity> getSynchronizables() {
		return synchronizables;
	}	
    
    «EXPAND filterField FOREACH this.filters»
    
}
  	
«ENDFILE»
«ENDDEFINE»



«REM»An empty definition for card entities«ENDREM»
«DEFINE generate(String packageName) FOR CardEntity»
«ENDDEFINE»

«REM»Set the actor roles«ENDREM»
«DEFINE setAuthorizedRoles FOR Role-»              
        authorizedRoles.add("«name»");
«ENDDEFINE»



«REM»Set the project roles to the actor«ENDREM»
«DEFINE setProjectRoles FOR emf::EObject-»«ENDDEFINE»
«DEFINE setProjectRoles FOR Project-»              
       	«FOREACH this.roles AS r-»         
        authorizedRoles.add("«r.name»");
		«ENDFOREACH -»
		//authorizedRoles.add("web");
		authorizedRoles.add("administrator");
		authorizedRoles.add("delete");
«ENDDEFINE»

«REM»
Create variable, getter and setter for the filter fields «ENDREM»
«DEFINE filterField FOR FilterField»

	/** 
	 * filter fields for the «this.entity.name.toFirstUpper()» entity 	
	 */		
	private Set<«entity.name.toFirstUpper()»> «EXPAND template::CommonFieldUtil::propertyName FOR this» = new HashSet<«entity.name.toFirstUpper()»>();
	
	/**
	 * Set the list of allowed «this.entity.name.toFirstUpper()» for card access.	
	 */
	public void «EXPAND template::CommonFieldUtil::setterName FOR this»(Set<«entity.name.toFirstUpper()»> filterFields){
		«EXPAND template::CommonFieldUtil::propertyName FOR this» = filterFields;
	}
	
	/**
	 * Get the list of allowed «this.entity.name.toFirstUpper()» for card access.
	 * @return a list of «this.entity.name.toFirstUpper()». 	
	 */
	public Set<«entity.name.toFirstUpper()»> «EXPAND template::CommonFieldUtil::getterName FOR this»(){
		return «EXPAND template::CommonFieldUtil::propertyName FOR this»;
	} 
«ENDDEFINE»