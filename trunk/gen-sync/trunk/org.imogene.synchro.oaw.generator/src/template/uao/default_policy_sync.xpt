«IMPORT core»
«EXTENSION template::CommonEntityUtilExt» 

«DEFINE generate(String packageName, String packagePath) FOR Project»
«FILE packagePath.toLowerCase() + "/uao/security/ImogDefaultPolicy.java"»
package «packageName.toLowerCase()».uao.security;

import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import org.imogene.common.dao.LocalizedTextDao;
import org.imogene.common.data.Synchronizable;
import org.imogene.common.data.SynchronizableUser;
import org.imogene.sync.server.hibernate.GenericHibernateDao;
import org.imogene.sync.localizedtext.LocalizedText;
import org.imogene.uao.role.Role;
import org.imogene.uao.security.ImogSecurityPolicy;
«FOREACH entities AS e-»
import «packageName.toLowerCase()».entity.«e.name»;
«IF Actor.isAssignableFrom(e.metaType)-»
import «packageName.toLowerCase()».entity.«e.name»User;
«ENDIF-»
«ENDFOREACH-»



/**
 * Class to filter beans so that only 
 * allowed bean data is accessible in read/write mode
 * @author Medes-IMPS
 */
public class ImogDefaultPolicy implements ImogSecurityPolicy {

	/* generic DAO access */
	private GenericHibernateDao dao;
	/* LocalizedText DAO access */
	private LocalizedTextDao i18nDao;


	/* (non-Javadoc)
	 * @see ImogSecurityPolicy#toHibernate(Synchronizable, SynchronizableUser)
	 */
	public Synchronizable toHibernate(Synchronizable bean, SynchronizableUser actor) {
	
		«FOREACH entities AS e»
		if (bean instanceof «e.name»)
			return toUnsecure«e.name»((«e.name») bean, getRoleNames(actor));	
		«ENDFOREACH»		

		return null;
	}


	/* (non-Javadoc)
	 * @see ImogSecurityPolicy#toHibernate(List, SynchronizableUser)
	 */
	public List<Synchronizable> toHibernate(List<Synchronizable> beans, SynchronizableUser actor) {
		List<Synchronizable> unsecuredList = new Vector<Synchronizable>();
		for (Synchronizable bean:beans) {
			Synchronizable toHibernate = toHibernate((Synchronizable) bean, actor);
			if (toHibernate!=null)
				unsecuredList.add(toHibernate);
		}
		return unsecuredList;
	}


	/* (non-Javadoc)
	 * @see ImogSecurityPolicy#toSecure(Synchronizable, SynchronizableUser)
	 */
	public Synchronizable toSecure(Synchronizable bean, SynchronizableUser actor) {

		«FOREACH entities AS e»
		«IF Actor.isAssignableFrom(e.metaType)-»
		if (bean instanceof «e.name»User)
			return toSecure«e.name»User((«e.name»User) bean, getRoleNames(actor));			
		«ELSE-»
		if (bean instanceof «e.name»)
			return toSecure«e.name»((«e.name») bean, getRoleNames(actor));			
		«ENDIF-»

		«ENDFOREACH»

		return null;
	}

	/* (non-Javadoc)
	 * @see ImogSecurityPolicy#toSecure(List, SynchronizableUser)
	 */
	public List<Synchronizable> toSecure(List<Synchronizable> beans, SynchronizableUser actor) {
		List<Synchronizable> securedList = new Vector<Synchronizable>();
		for (Synchronizable bean:beans) {
			Synchronizable isSecured = toSecure(bean, actor);
			if (isSecured!=null)
				securedList.add(isSecured);
		}
		return securedList;
	}
	
	«FOREACH entities AS e»
	/**
	 * Secure a «e.name» bean.
	 * 
	 * @param bean The «e.name» bean to secure
	 * @param roleNames set of role ids for the user 
	 * @return A secured «e.name» bean
	 */
		«IF Actor.isAssignableFrom(e.metaType)-»
	private SynchronizableUser toSecure«e.name»User(«e.name»User bean, Set<String> roleNames) {

		boolean isSecured = false;
		«e.name»User transformedBean = new «e.name»User();				
		«ELSE-»
	private Synchronizable toSecure«e.name»(«e.name» bean, Set<String> roleNames) {

		boolean isSecured = false;
		«e.name» transformedBean = new «e.name»();		
		«ENDIF-»	 

		/* unsecured data */
		transformedBean.setId(bean.getId());
		transformedBean.setModifiedBy(bean.getModifiedBy());
		transformedBean.setModifiedFrom(bean.getModifiedFrom());
		transformedBean.setModified(bean.getModified());
		transformedBean.setUploadDate(bean.getUploadDate());
		transformedBean.setCreatedBy(bean.getCreatedBy());
		transformedBean.setCreated(bean.getCreated());		
		«IF Actor.isAssignableFrom(e.metaType)-»
		transformedBean.setLogin(bean.getLogin());
		transformedBean.setPassword(bean.getPassword());
		transformedBean.setRoles(bean.getRoles());	
		«EXPAND filterField FOREACH ((Actor)e).filters-»		
		«ENDIF-»			
		
		«FOREACH e.groups AS g»
			«IF g.readers.size == 0»
		if (!isSecured) isSecured = true;
				«FOREACH g.fields AS f-»
					«EXPAND setField(true) FOR f -»
				«ENDFOREACH-»			
			«ELSE»
				if(«FOREACH g.readers AS r ITERATOR i» roleNames.contains("«r.name»") «IF !i.lastIteration»||«ENDIF»«ENDFOREACH»«IF g.writers.size>0»||«ENDIF»«FOREACH g.writers AS w ITERATOR i» roleNames.contains("«w.name»") «IF !i.lastIteration»||«ENDIF»«ENDFOREACH»){
					if (!isSecured) isSecured = true;
					«FOREACH g.fields AS f-»
						«EXPAND setField(true) FOR f -»
					«ENDFOREACH-»
				}
				else{
				«FOREACH g.fields AS f-»
						«EXPAND setEmptyField FOR f -»
				«ENDFOREACH-»
				}
			«ENDIF»
		«ENDFOREACH»
		
		«IF isTranslatableFieldPresent(e.groups.fields)-»
		transformedBean = getLocalized«e.name.toFirstUpper()»(transformedBean, roleNames);
		«ENDIF-»				

		if (isSecured)
			return transformedBean;
		else
			return null;
	}

	/**
	 * Unsecure a «e.name» bean.
	 * @param bean The «e.name» bean to unsecure
	 * @param roleNames set of role ids for the user
	 * @return A unsecured «e.name» bean
	 */
	private Synchronizable toUnsecure«e.name»(«e.name» bean, Set<String> roleNames) {
		
		boolean isSecured = false;
		«e.name» transformedBean = («e.name») dao.getBean(«e.name».class, bean.getId());

		if (transformedBean == null) {
			«IF Actor.isAssignableFrom(e.metaType)-»
			transformedBean = new «e.name»User();
			«ELSE-»
			transformedBean = new «e.name»();
			«ENDIF-»
			transformedBean.setId(bean.getId());
		}
		transformedBean.setModifiedBy(bean.getModifiedBy());
		transformedBean.setModifiedFrom(bean.getModifiedFrom());
		transformedBean.setModified(bean.getModified());
		transformedBean.setUploadDate(bean.getUploadDate());
		transformedBean.setCreatedBy(bean.getCreatedBy());
		transformedBean.setCreated(bean.getCreated());									
		
		«FOREACH e.groups AS g»
			«IF g.writers.size == 0»
				«IF g.readers.size>0»					
					if(«FOREACH g.readers AS r ITERATOR i» roleNames.contains("«r.name»") «IF !i.lastIteration»||«ENDIF»«ENDFOREACH»){		
						if (!isSecured) isSecured = true;			
					«FOREACH g.fields AS f-»
						«EXPAND setField(false) FOR f-»
					«ENDFOREACH-»
				}
				«ELSE»
						if (!isSecured) isSecured = true;
					«FOREACH g.fields AS f-»
						«EXPAND setField(false) FOR f -»
					«ENDFOREACH-»
				«ENDIF»									
			«ELSE»
				if(«FOREACH g.writers AS r ITERATOR i» roleNames.contains("«r.name»") «IF !i.lastIteration»||«ENDIF»«ENDFOREACH»){
					if (!isSecured) isSecured = true;
					«FOREACH g.fields AS f-»
						«EXPAND setField(false) FOR f-»
					«ENDFOREACH-»
				}				
			«ENDIF»
		«ENDFOREACH»

		if (isSecured)
			return transformedBean;
		else
			return null;
	}	
	«ENDFOREACH»	
	
	
	«FOREACH entities AS e-»	
		«IF isTranslatableFieldPresent(e.groups.fields)-»
	/**
	 * Adds the Localized texts to a «e.name.toFirstUpper()-» entity
	 * @param value the «e.name.toFirstUpper()-» entity
	 * @param roleNames set of role ids for the user 
	 * @return «e.name.toFirstUpper()-» entity with the Localized texts added
	 */
	private «e.name.toFirstUpper()-» getLocalized«e.name.toFirstUpper()-»(«e.name.toFirstUpper()-» value, Set<String> roleNames) {
		«e.name.toFirstUpper()-» entity = value;
		if (entity!=null) {
			«FOREACH e.groups AS g-»
				«IF isTranslatableFieldPresent(g.fields)-»			
					«IF g.readers.size == 0-»
						«FOREACH g.fields AS f-»
							«EXPAND addLocalizedTexts FOREACH g.fields-»
						«ENDFOREACH-»			
					«ELSE-»
						if(«FOREACH g.readers AS r ITERATOR i» roleNames.contains("«r.name»") «IF !i.lastIteration»||«ENDIF»«ENDFOREACH»«IF g.writers.size>0»||«ENDIF»«FOREACH g.writers AS w ITERATOR i» roleNames.contains("«w.name»") «IF !i.lastIteration»||«ENDIF»«ENDFOREACH» || roleNames.contains("administrator")){
							«EXPAND addLocalizedTexts FOREACH g.fields-»
						}
					«ENDIF-»				
				«ENDIF-»
			«ENDFOREACH-»
		}		
		return entity;		
	}	
		«ENDIF-»
	«ENDFOREACH-»
	
	/**
	 * Gets the Localized texts for a given field
	 * @param fieldId the field id for which LocalizedTexts are searched
	 * @return a list of LocalizedTexts
	 */
	private List<LocalizedText> getLocalizedTexts(String fieldId) {
		return i18nDao.listLocalizedText(fieldId);	
	}
			
	
	/**
	 * 
	 * @param from
	 * @param to
	 */
	@SuppressWarnings("unchecked")
	private void updateCollection(Set from, Set to) {
		to.clear();
		for (Iterator it = from.iterator(); it.hasNext();) {
			to.add(it.next());
		}
		/*Be careful, very strange Hibernate behaviour,
		  it accepts to persist a collection cleared and populated,
		  but doesn't want to persist a collection cleared and let empty.
		  SO we create a new HashSet.
		 */
		if (from.size() == 0) {
			to = new HashSet();
		}
	}

	/**
	 * 
	 * @param actor the actor for which roles are looked for
	 * @return list of role ids
	 */
	private Set<String> getRoleNames(SynchronizableUser actor) {
		Set<String> names = new HashSet<String>();
		if (actor != null) {
			for (Role role:actor.getRoles()) {
				names.add(role.getId());
			}
		}
		return names;
	}
	
	
	/**
	 * Setter for bean injection
	 * @param dao
	 */
	public void setDao(GenericHibernateDao dao) {
		this.dao = dao;
	}
	
	public void setI18nDao(LocalizedTextDao i18nDao) {
		this.i18nDao = i18nDao;
	}
}

«ENDFILE»
«ENDDEFINE»
«REM» ------------------------------------------------«ENDREM»


«REM» Setter to affect the values to the new bean «ENDREM»
«DEFINE setField(boolean toSecure) FOR FieldEntity-»
	transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»(bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»());
«ENDDEFINE»

«DEFINE setField(boolean toSecure) FOR TextField-»
	transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»(bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»());
	«IF this.translatable-»
		«IF !toSecure-»
	transformedBean.getLocalizedFieldMap().addI18nValues(bean.getLocalizedFieldMap().getFieldI18nValues(bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»()));
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE setField(boolean toSecure) FOR GeoField-»
	transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»Latitude(bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»Latitude());
	transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»Longitude(bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»Longitude());
«ENDDEFINE»

«DEFINE setField(boolean toSecure) FOR RelationFieldEntity-»
	«IF this.cardinality>1 || this.cardinality==-1 -»
	updateCollection(bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»(), transformedBean.«EXPAND template::CommonFieldUtil::getterName FOR this-»());
	«ELSE»
	if(transformedBean.«EXPAND template::CommonFieldUtil::getterName FOR this-»()==null ||
		bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»() == null ||
		!transformedBean.«EXPAND template::CommonFieldUtil::getterName FOR this-»().getId().equals(bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»().getId())){
		transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»(bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»());
	}
	«ENDIF-»
«ENDDEFINE»


«REM» Set empty field to secure a bean «ENDREM»
«DEFINE setEmptyField FOR FieldEntity-»
	transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»(null);
«ENDDEFINE»

«DEFINE setEmptyField FOR GeoField-»
	transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»Latitude(null);
	transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»Longitude(null);
«ENDDEFINE»

«DEFINE setEmptyField FOR RelationFieldEntity-»
	«IF this.cardinality>1 || this.cardinality==-1 -»
		transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»(new HashSet<«this.entity.name»>());
	«ELSE-»
		transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»(null);
	«ENDIF-»
«ENDDEFINE»


«REM»  «ENDREM»
«DEFINE filterField FOR FilterField-»
transformedBean.«EXPAND template::CommonFieldUtil::setterName FOR this-»(bean.«EXPAND template::CommonFieldUtil::getterName FOR this-»());
«ENDDEFINE»

«REM» Add LocalizedTexts to translatable entity «ENDREM»
«DEFINE addLocalizedTexts FOR FieldEntity-»«ENDDEFINE»
«DEFINE addLocalizedTexts FOR TextField-»
	«IF this.translatable-»
			entity.getLocalizedFieldMap().addI18nValues(getLocalizedTexts(entity.«EXPAND template::CommonFieldUtil::getterName FOR this-»()));
	«ENDIF-»
«ENDDEFINE»
«REM» ---------------------------------------------------------- «ENDREM»



