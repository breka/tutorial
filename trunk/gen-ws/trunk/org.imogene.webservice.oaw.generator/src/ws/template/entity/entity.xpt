«IMPORT core»
«EXTENSION template::CommonFieldUtilExt» 
«EXTENSION template::CommonEntityUtilExt» 

«DEFINE generate(String packageName, String projectName) FOR CardEntity»
«FILE packageName.toLowerCase()+ "/entity/" + this.name.toFirstUpper() + ".java"»
package org.imogene.«projectName.toLowerCase()».entity;

import java.util.Date;
import java.util.Set;
«IF Actor.isAssignableFrom(this.metaType)-»
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
«ENDIF-»

import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

«IF !Actor.isAssignableFrom(this.metaType)-»
import org.imogene.ws.entity.MedooBean;
«ELSE-»
import org.imogene.ws.entity.MedooActor;
import org.imogene.ws.entity.MedooRole;
import org.imogene.ws.entity.SynchronizableEntity;
«ENDIF-»
import org.imogene.ws.entity.GeoField;
import org.imogene.ws.serializer.xml.DateAdapter;
«FOREACH groups.fields AS f -»
	«EXPAND RelationEntityDeclaration(projectName) FOR f-»
«ENDFOREACH -»	
«IF this.georeferenced!=null -»
import org.imogene.ws.entity.IsGeoreferenced;
«ENDIF-»
«IF isTranslatableFieldPresent(this.groups.fields)-»
import org.imogene.ws.entity.LocalizedField;
«ENDIF-»	


/**
 * MedooBean implementation for the entity «name.toFirstUpper()»
 * @author MEDES-IMPS
 */
@XmlRootElement(name="«name.toLowerCase()»")
@XmlType( propOrder={«EXPAND setOrder FOREACH this.groups.fields SEPARATOR ","-», "creationDate", "lastModificationDate", "uploadDate", "creator", "modifier", "modifiedFrom"} )
«IF !Actor.isAssignableFrom(this.metaType)-»
public class «name.toFirstUpper()» implements MedooBean {
«ELSE-»
public class «name.toFirstUpper()» implements MedooActor {
«ENDIF-»

	/* Medoo bean fields */
	private String id;	
	private Date creationDate;
	private Date lastModificationDate;	
	private Date uploadDate;
	private String creator;
	private String modifier;
	private String modifiedFrom;
	
	«IF Actor.isAssignableFrom(this.metaType)-»
	/* Medoo actor fields */	
	private String login;
	private String password;
	private String notifLocale;
	private Integer defaultNotificationMethod;
	private Boolean beNotified;
	private HashMap<String, String> notificationData = new HashMap<String, String>();
	private Set<SynchronizableEntity> synchronizables = new HashSet<SynchronizableEntity>();
	private Set<MedooRole> assignedRoles = new HashSet<MedooRole>();
	private Date lastLoginDate;	
	«ENDIF-»	
	
	/* Entity fields */
	
	«FOREACH groups AS g-»
	/* «g.name.toFirstUpper()» group fields */
	«FOREACH g.fields AS f -»
	«EXPAND fieldDeclaration FOR f-»
	«ENDFOREACH -»	
	«ENDFOREACH»	
	
	
	public «name.toFirstUpper()»(){
	
		«IF Actor.isAssignableFrom(this.metaType)-»
	       «IF ((Actor)this).notificationInfos != null -»
	          «FOREACH ((Actor)this).notificationInfos AS nf-»        
	            notificationData.put("«nf.method»", "«EXPAND template::CommonFieldUtil::getterName FOR nf.dataField-»");        
	          «ENDFOREACH -»
	  	   «ENDIF -»
		«ENDIF-»		
	}
	
	/* Getters for Medoo bean fields */
	
	@XmlJavaTypeAdapter(value=DateAdapter.class)
	@XmlElement(name="creationdate")
	public Date getCreationDate() {		
		return creationDate;
	}	

	public String getCreator() {		
		return creator;
	}

	@XmlAttribute
	public String getId() {		
		return id;
	}

	@XmlJavaTypeAdapter(value=DateAdapter.class)
	@XmlElement(name="lastmodificationdate")
	public Date getLastModificationDate() {		
		return lastModificationDate;
	}

	@XmlElement(name="modifiedfrom")
	public String getModifiedFrom() {		
		return modifiedFrom;
	}

	public String getModifier() {		
		return modifier;
	}

	@XmlJavaTypeAdapter(value=DateAdapter.class)
	@XmlElement(name="uploaddate")
	public Date getUploadDate() {		
		return uploadDate;
	}
	
	/* Setters for Medoo bean fields */

	public void setCreationDate(Date date) {		
		creationDate = date;
	}

	public void setCreator(String pCreator) {
		creator =pCreator;		
	}

	public void setId(String pId) {		
		id = pId;
	}

	public void setLastModificationDate(Date date) {
		lastModificationDate = date;		
	}

	public void setModifiedFrom(String terminal) {
		modifiedFrom = terminal;		
	}

	public void setModifier(String pModifier) {
		modifier = pModifier;		
	}

	public void setUploadDate(Date date) {		
		uploadDate = date;
	}
	
	/* Getters and Setters for Entity fields */
	
	«FOREACH groups AS g-»
	/* Getters and Setters for «g.name.toFirstUpper()» group fields */
	«FOREACH g.fields AS f -»
	«EXPAND ws::template::WsFieldUtil::getterDeclarationForField FOR f»
	«EXPAND ws::template::WsFieldUtil::setterDeclarationForField FOR f»	
	«REM»
	When a property has a lowercase first char and an upper case second char,
	some bean introspectors need getter/setter with type getXxxx
	and some other need getter/setter with type getxxx
	«ENDREM»
	«IF isPropertyWithLowerUpperCaseFirstTwoChar(f.name)-»
	/* second set of getter/setter because of property has first char with lowercase and second char with uppercase 
	   and bean introspectors do not use same naming conventions */
	«EXPAND ws::template::WsFieldUtil::getterDeclarationForFieldWithLowerUpperCaseFirstTwoChar FOR f»
	«EXPAND ws::template::WsFieldUtil::setterDeclarationForFieldWithLowerUpperCaseFirstTwoChar FOR f-»
	/* ----------------------------------------------------------------------------------------------------------- */
	«ENDIF-»
	
	«IF RelationFieldEntity.isAssignableFrom(f.metaType) && (((RelationFieldEntity)f).cardinality != 1)-»
	/**
	 * @param param the «((RelationFieldEntity)f).entity.name-» to add to the «EXPAND template::CommonFieldUtil::propertyName FOR f-» collection
	 */
	public void addTo«EXPAND template::CommonFieldUtil::propertyName FOR f-»(«((RelationFieldEntity)f).entity.name.toFirstUpper()-» param)
	{
		«EXPAND template::CommonFieldUtil::propertyName FOR f-».add(param);
	}	
	
	/**
	 * @param param the «((RelationFieldEntity)f).entity.name-» to remove from the «EXPAND template::CommonFieldUtil::propertyName FOR f-» collection
	 */
	public void removeFrom«EXPAND template::CommonFieldUtil::propertyName FOR f-»(«((RelationFieldEntity)f).entity.name.toFirstUpper()-» param)
	{
		«EXPAND template::CommonFieldUtil::propertyName FOR f-».remove(param);
	}	
	«ENDIF-»	
	
	
	«ENDFOREACH -»	
	«ENDFOREACH»	
	
	«IF this.georeferenced!=null -»
	public Double getLatitude() {
		return «EXPAND template::CommonFieldUtil::propertyName FOR this.georeferenced»Latitude;
	}
	public Double getLongitude() {
		return «EXPAND template::CommonFieldUtil::propertyName FOR this.georeferenced»Longitude;
	}
	«ENDIF»	
	
	public String getDisplayValue() {		
		StringBuffer buffer = new StringBuffer();
		«FOREACH this.mainFields AS m -»
		//TODO Compute main fields
		«ENDFOREACH -»
		return buffer.toString();
	}
	
	«IF Actor.isAssignableFrom(this.metaType)-»
	/* Getters and Setters for Actor fields */
	
	/** 
	 * Get the assigned roles for this actor. 
	 * @return a list of role names (EMPTY_LIST if none). 	  
	 */
	@XmlTransient
	public Set<MedooRole> getRoles() {
		return assignedRoles;
	}

	/**
	 * Set the list of roles assigned to this actor. 	 
	 * @param roles the list of roles assigned. 
	 */
	public void setRoles(Set<MedooRole> roles) {
		assignedRoles = roles;
	}

	/** 
	 * Add a role to this actor.
	 * @param role the role to add.
	 */
	public void addRole(MedooRole role) {

		if (!isRoleAuthorized(role.getId())) {
			throw new IllegalArgumentException(
					"The role "
							+ role.getName()
							+ " can not be assigned to this actor (not defined as an authorized role), for actor : FamilyDoctor");
		}

		if (!isRoleAssigned(role.getId())) {
			assignedRoles.add(role);
		}
	}

	/** 
	 * Remove the specified role of this actor assigned roles
	 */
	public void removeRole(MedooRole role) {
		assignedRoles.remove(role);
	}

    /** 
     * Get the authorized roles for this actor. (defined in model).    
     * @return a list of roles names (EMPTY_LIST if none).  
     */
    public static Set<String> getAuthorizedRoles() {
    	
    	Set<String> authorizedRoles = new HashSet<String>();
    	    	
    	«IF !((Actor)this).authorizedRoles.isEmpty -»
		    «FOREACH ((Actor)this).authorizedRoles AS role-»
				«EXPAND setAuthorizedRoles FOR role-»
			«ENDFOREACH -»   
		«ELSE -»
			«EXPAND setProjectRoles FOR this.eContainer-»				
		«ENDIF -»  
        
        return authorizedRoles;
    }

	/** 
	 * Get this actor login.
	 *@return the actor login
	 */
	@XmlTransient
	public String getLogin() {
		return login;
	}

	/** 
	 * Get the assigned password for this actor.
	 *@return the actor password 
	 */
	@XmlTransient
	public String getPassword() {
		return password;
	}

	/**
	 * Set the actor login.
	 *@param pLogin the actor login.
	 */
	public void setLogin(String pLogin) {
		login = pLogin;
	}

	/**
	 * set the actor password
	 *@param pPassword the actor password 
	 */
	public void setPassword(String pPassword) {
		password = pPassword;
	}

	/** 
	 * Get the notification locale ISO code to use for this actor
	 *@return the locale ISO code
	 */
	@XmlTransient
	public String getNotificationLocale() {
		return notifLocale;
	}

	/** 
	 * Set the notification locale ISO code
	 *@param locale the locale ISO code
	 */
	public void setNotificationLocale(String locale) {
		notifLocale = locale;
	}

	/** 
	 * Get the notification method to use (if none : NO_METHOD). 
	 * @return the notification method id
	 */
	@XmlTransient
	public Integer getNotificationMethod() {
		return defaultNotificationMethod;
	}

	/**
	 * Set the notification method to use.
	 *@param method the notification method
	 */
	public void setNotificationMethod(Integer method) {
		defaultNotificationMethod = method;
	}

	/**
	 * get the notification data (ie: phone number, email) 
	 * for the specified notification method.
	 * @param method the notification method
	 * @return the data associated with the method
	 */
	public String getNotificationDataMethodName(String method) {
		return (String) notificationData.get(method);
	}

	/** 
	 * This actor can be notified ?
	 *@return true if actor can be notified.
	 */
	@XmlTransient
	public Boolean getBeNotified() {
		return beNotified;
	}

	/**
	 * Set if this actor can be notified
	 *@param notif true if it can be notified
	 */
	public void setBeNotified(Boolean notif) {
		beNotified = notif;
	}

	/** 
	 * Is the specified role already assigned to the user ?
	 * @param roleId the role id
	 * @return true it is already assigned
	 */
	private boolean isRoleAssigned(String roleId) {
		boolean result = false;
		if (assignedRoles != null) {
			for (Iterator<MedooRole> it = assignedRoles.iterator(); it
					.hasNext() && !result;) {
				MedooRole currRole = (MedooRole) it.next();
				result = currRole.getId().equals(roleId);
			}
		}
		return result;
	}

	/**
	 * Is the specified role authorised for this type of user ?
	 * @param roleId the role id
	 * @return true it is authorised
	 */
	private boolean isRoleAuthorized(String roleId) {
		boolean result = false;
		if (getAuthorizedRoles() != null) {
			for (Iterator<String> iter = getAuthorizedRoles().iterator(); iter
					.hasNext() && !result;) {
				String currRoleId = (String) iter.next();
				result = currRoleId.equals(roleId);
			}
		}
		return result;
	}

	/**
	 * Get the actor last login date
	 */
	@XmlTransient
	public Date getLastLoginDate() {
		return lastLoginDate;
	}

	/**
	 * Set the actor last login date
	 */
	public void setLastLoginDate(Date date) {
		this.lastLoginDate = date;
	}

	/**
	 * Set the entities that the actor can synchronize
	 */
	public void setSynchronizables(Set<SynchronizableEntity> syncs) {
		synchronizables = syncs;
	}

	/**
	 * Get the entities that the actor can synchronize
	 */
	@XmlTransient
	public Set<SynchronizableEntity> getSynchronizables() {
		return synchronizables;
	}
	
	    «EXPAND filterField FOREACH ((Actor)this).filters»
	«ENDIF-»		
	
}
«ENDFILE»
«ENDDEFINE»

«DEFINE fieldDeclaration FOR FieldEntity-»
	private «EXPAND ws::template::WsFieldUtil::entityFieldType FOR this -» «EXPAND template::CommonFieldUtil::propertyName FOR this»; 
«ENDDEFINE»

«DEFINE fieldDeclaration FOR TextField-»
	private «EXPAND ws::template::WsFieldUtil::entityFieldType FOR this -» «EXPAND template::CommonFieldUtil::propertyName FOR this»;
	«IF this.translatable -»
	private LocalizedField «EXPAND template::CommonFieldUtil::propertyName FOR this»LocalizedField;
	«ENDIF -»
«ENDDEFINE»

«DEFINE fieldDeclaration FOR GeoField-»
	private «EXPAND ws::template::WsFieldUtil::entityFieldType FOR this -» «EXPAND template::CommonFieldUtil::propertyName FOR this»Latitude; 
	private «EXPAND ws::template::WsFieldUtil::entityFieldType FOR this -» «EXPAND template::CommonFieldUtil::propertyName FOR this»Longitude; 
	private GeoField «EXPAND template::CommonFieldUtil::propertyName FOR this» = new GeoField(); 
«ENDDEFINE»

«DEFINE RelationEntityDeclaration(String projectName) FOR FieldEntity-»«ENDDEFINE»
«DEFINE RelationEntityDeclaration(String projectName) FOR RelationFieldEntity-»
	«IF this.cardinality == 1 -»
import org.imogene.«projectName.toLowerCase()».entity.serializer.xml.«entity.name.toFirstUpper()»Adapter;
	«ELSE -»
import org.imogene.«projectName.toLowerCase()».entity.serializer.xml.«entity.name.toFirstUpper()»ListAdapter;
	«ENDIF -»
«ENDDEFINE»

«DEFINE setOrder FOR FieldEntity»"«EXPAND template::CommonFieldUtil::propertyName FOR this»"«ENDDEFINE»
«DEFINE setOrder FOR TextField»«IF this.translatable»"«EXPAND template::CommonFieldUtil::propertyName FOR this»LocalizedField"«ELSE»"«EXPAND template::CommonFieldUtil::propertyName FOR this»"«ENDIF»«ENDDEFINE»


«REM»Set the actor roles«ENDREM»
«DEFINE setAuthorizedRoles FOR Role-»              
        authorizedRoles.add("«name»");
«ENDDEFINE»



«REM»Set the project roles to the actor«ENDREM»
«DEFINE setProjectRoles FOR emf::EObject-»«ENDDEFINE»
«DEFINE setProjectRoles FOR Project-»              
       	«FOREACH this.roles AS r-»         
        authorizedRoles.add("«r.name»");
		«ENDFOREACH -»
		//authorizedRoles.add("web");
		authorizedRoles.add("administrator");
		authorizedRoles.add("delete");
«ENDDEFINE»

«REM» Create variable, getter and setter for the filter fields «ENDREM»
«DEFINE filterField FOR FilterField»

	/** 
	 * filter fields for the «this.entity.name.toFirstUpper()» entity 	
	 */		
	private Set<«entity.name.toFirstUpper()»> «EXPAND template::CommonFieldUtil::propertyName FOR this» = new HashSet<«entity.name.toFirstUpper()»>();
	
	/**
	 * Set the list of allowed «this.entity.name.toFirstUpper()» for card access.	
	 */
	public void «EXPAND template::CommonFieldUtil::setterName FOR this»(Set<«entity.name.toFirstUpper()»> filterFields){
		«EXPAND template::CommonFieldUtil::propertyName FOR this» = filterFields;
	}
	
	/**
	 * Get the list of allowed «this.entity.name.toFirstUpper()» for card access.
	 * @return a list of «this.entity.name.toFirstUpper()». 	
	 */
	public Set<«entity.name.toFirstUpper()»> «EXPAND template::CommonFieldUtil::getterName FOR this»(){
		return «EXPAND template::CommonFieldUtil::propertyName FOR this»;
	} 
«ENDDEFINE»
